# 面试题整理

## 一、深浅拷贝

### 1.数据类型

基本数据类型：number、string、boolean、null、undefined
引用数据类型：object、function、array

### 2.深拷贝

什么是深拷贝：

简单来说，深拷贝就是不管是基本数据类型还是引用数据类型都重新拷贝一份， 不存在共用数据的现象

即深拷贝就是完完全全拷贝一份新的对象，它会在内存的堆区域重新开辟空间，修改拷贝对象就不会影响到源对象

深浅拷贝是针对于引用数据类型

#### 深拷贝实现

##### 1.`JSON.parse(JSON.stringify(object/待拷贝对象))`

存在问题：

会忽略 `undefined`

会忽略 `symbol`

不能序列化函数

不能解决循环引用的对象

不能正确处理`new Date()`

不能处理正则

不能处理new Error()

##### 2.递归的方式来实现深拷贝

##### 3.使用lodash中的_.cloneDeep(object/待拷贝对象)

### 3.浅拷贝

什么是浅拷贝：

  对对象而言，它的第一层属性值如果是基本数据类型则完全拷贝一份数据，如果是引用类型就拷贝内存地址。

#### 浅拷贝的实现

对象方法Object.assign()

数组方法slice()/数组方法concat()

### 4.深浅拷贝区别与区分

#### 区别：

**深拷贝**：将数据中所有的数据赋值过去，无限层级拷贝,，每一级别的数据都会拷贝出来，所有元素或属性均完全复制，与原对象完全脱离，在堆中重新分配内存, 将源对象的各个属性复制进去，拷贝后，修改拷贝后的对象，不影响之前的对象。

**浅拷贝**：将原有的数据赋值过去，只进行一层拷贝，深层次的对象级别的就拷贝引用，原始类型为值传递，对象类型仍为引用传递，是拷贝引用, 拷贝后的引用都是指向同一个存放数据位置的指针，拷贝后，修改拷贝后的对象，会影响拷贝前的对象。

#### 区分：

**简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短；如果B没变，那就是深拷贝，自食其力。**



## 二、数据存储

在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是`cookie`，`localstorage`和`sessionStorage` 

### 1.cookie

cookie 可通过 document.cookie 获取全部 cookie。它是一段字符串，是键值对的形式。

#### 保存cookie值：

```
let dataCookie='110';
document.cookie = 'token' + "=" +dataCookie; 
```

#### 获取指定名称的cookie值

```
function getCookie(name) { //获取指定名称的cookie值
// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；
let arr = document.cookie.match(new RegExp("(^| )"+name+"=([^;]*)(;|$)"));
if(arr != null) {
  console.log(arr);
  return unescape(arr[2]);
}
return null;
}
let cookieData=getCookie('token'); //       cookie赋值给变量。
```

以上操作起来有些麻烦，可引入封装好的库进行使用，比如 js-cookie点我。API 也很简洁：

```
Cookies.set("name", "value", { expires: 7 }); // 设置一个cookie，7天后失效

Cookies.get("name"); // => 'value'

Cookies.remove("name");
```

#### cookie 和 session 区别：

- cookie 数据存放在客户端，session 数据放在服务器端。
- cookie 本身并不安全，考虑到安全应当使用 session。
- 默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）
- session 会在一定时间内保存在服务器上。如果访问量比较大，会比较消耗服务器的性能。考虑到减轻服务器性能方面的开销，应当使用 cookie 。
- 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个域名最多保存 50 个 cookie。 将登陆信息等重要信息存放为 session、其他信息如果需要保留，可以放在 cookie 中。

### 2.`localStorage `和 `sessionStorage`

在 web 本地存储场景上，cookie 的使用受到种种限制，最关键的就是存储容量太小和数据无法持久化存储。在 HTML 5 的标准下，出现了 `localStorage` 和 `sessionStorage `供我们使用。

```
localStorage.setItem("name", "value");
localStorage.getItem("name"); // =>        'value'
localStorage.removeItem("name");
localStorage.clear(); // 删除所有数据

sessionStorage.setItem("name", "value");
sessionStorage.setItem("name");
sessionStorage.setItem("name");
sessionStorage.clear();
```

### 3.注意事项

- localStorage 写入的时候，如果超出容量会报错，但之前保存的数据不会丢失。
- localStorage 存储容量快要满的时候，getItem 方法性能会急剧下降。
- web storage 在保存复杂数据类型时，较为依赖 JSON.stringify，在移动端性能问题比较明显。

## 三、判断数据类型

#### 1.`typeof`（判断基本数据类型）

```
typeof '5' // string
typeof 5 // number
typeof null // object
typeof undefined // undefined
typeof true // boolean
typeof Symbol('5') // symbol
typeof 5n // bigint
typeof new Object(); // object
typeof new Function(); // function
```

#### 2.`instanceof`（判断复杂数据类型）

```
[] instanceof Array; // true
[] instanceof Object; // true

function Person() {};
const person = new Person();

person instanceof Person; // true
person instanceof Object; // true
```

#### 3.`toString`（判断复杂数据类型）

```
Object.prototype.toString.call('5') // [object String]
Object.prototype.toString.call(5) // [object Number]
Object.prototype.toString.call([5]) // [object Array]
Object.prototype.toString.call(true) // [object Boolean]
Object.prototype.toString.call(undefined) // [object Undefined]
Object.prototype.toString.call(null) // [object Null]
Object.prototype.toString.call(new Function()); // [object Function]
Object.prototype.toString.call(new Date()); // [object Date]
Object.prototype.toString.call(new RegExp()); // [object RegExp]
Object.prototype.toString.call(new Error()); // [object Error]
```

